CREATE OR REPLACE PACKAGE IR_TO_XML AS    
 
  -- used for debug
  function get_report_query(p_app_id       in number,
                            p_page_id      in number,
                            p_ir_static_id in varchar2 default null
                           )
  return varchar2;  
  
  -- download interactive report as PDF
  procedure get_report_document(p_app_id       in number,
                                p_layout_id in APEX_REPORT_LAYOUTS.id%TYPE,
                                p_page_id      in number,                               
                                p_ir_static_id in varchar2 default null
                               );
  -- used for debug
  function get_report_xml(p_app_id       in number,
                          p_page_id      in number,
                          p_ir_static_id in varchar2 default null)
  return clob;
  
  
 --<xsl:variable name="_XDOXSLTCTX" select="xdoxslt:set_xslt_locale($_XDOCTX, $_XDOLOCALE, $_XDOTIMEZONE, $_XDOCALENDAR, $_XDODFOVERRIDE, $_XDOCURMASKS, $_XDONFSEPARATORS)"/>
--<fo:root xdofo:nf-separator="{$_XDONFSEPARATORS}">
v_template2 clob := '<?xml version = ''1.0'' encoding = ''utf-8''?>
<!--Generated by Oracle BI Publisher 11.1.1.6.1-->
<!--xslt1.0-compatibility-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:ora="http://www.oracle.com/XSL/Transform/java/" xmlns:xdofo="http://xmlns.oracle.com/oxp/fo/extensions" xmlns:xdoxslt="http://www.oracle.com/XSL/Transform/java/oracle.xdo.template.rtf.XSLTFunctions" xmlns:xdoxliff="urn:oasis:names:tc:xliff:document:1.1" xmlns:xlink="http://www.w3.org/1999/xlink">
   <xsl:param name="_XDOCALENDAR">GREGORIAN</xsl:param>
   <xsl:param name="_XDOLOCALE">en-us</xsl:param>
   <xsl:param name="_XDOTIMEZONE">GMT</xsl:param>
   <xsl:param name="_XDODFOVERRIDE">;</xsl:param>
   <xsl:param name="_XDOCURMASKS">;</xsl:param>
   <xsl:param name="_XDONFSEPARATORS"></xsl:param>
   <xsl:param name="_XDOCHARTTYPE">image/svg+xml</xsl:param>
   <xsl:param name="_XDOOUTPUTFORMAT">application/pdf</xsl:param>
   <xsl:param name="_XDOSVGFONTEMBED">true</xsl:param>
   <xsl:param name="_XDODEFDATE"/>
   <xsl:param name="_XDODEFTIME"/>
   <xsl:param name="_XDODEFNUM"/>
   <xsl:param name="_XDODEFCC"/>
   <xsl:param name="_XDOCTX">#</xsl:param>
   
   <xsl:variable name="titlevar" select="''RTF Template''" />
   <xsl:variable name="_XDOFOPOS" select="''''"/>
   <xsl:variable name="_XDOFOPOS2" select="number(1)"/>
   <xsl:variable name="_XDOFOTOTAL" select="number(1)"/>
   <xsl:variable name="_XDOFOOSTOTAL" select="number(0)"/>
   <xsl:template match="/">
      <fo:root >
         
         
         <fo:layout-master-set>
            <fo:simple-page-master master-name="master0" margin-left="65.45pt" margin-right="65.45pt" page-height="841.9pt" page-width="595.3pt" margin-top="35.4pt" margin-bottom="35.4pt">
               
               
               <fo:region-body region-name="region-body" margin-top="35.45pt" margin-bottom="21.3pt"/><fo:region-before region-name="region-header" extent="35.45pt"/><fo:region-after region-name="region-footer" extent="21.3pt" display-align="after"/>
            </fo:simple-page-master>
         </fo:layout-master-set>
         <fo:page-sequence master-reference="master0">
            
               
            
            <xsl:variable name="_PW" select="number(595.3)" />
            <xsl:variable name="_PH" select="number(841.9)" />
            <xsl:variable name="_ML" select="number(70.85)" />
            <xsl:variable name="_MR" select="number(70.85)" />
            <xsl:variable name="_MT" select="number(70.85)" />
            <xsl:variable name="_MB" select="number(56.7)" />
            <xsl:variable name="_HY" select="number(35.399998)" />
            <xsl:variable name="_FY" select="number(35.4)" />
            <xsl:variable name="_SECTION_NAME" select="string(''master0'')" />
            
            
            <fo:flow flow-name="region-body">
               <fo:block padding-bottom="0.0pt" padding-top="0.0pt">
                  <fo:table start-indent="0.0pt"     >
                     <xsl:variable name="_XDOFOPOS2" select="number(1)"/>
                     <xsl:variable name="_XDOFOTOTAL" select="number(1)"/>
                     <fo:table-column column-width="230.3pt"/>
                     <fo:table-column column-width="230.3pt"/>
                     <fo:table-body>
                        <fo:table-row>
                           <fo:table-cell padding-end="5.4pt" padding-bottom="0.0pt" padding-start="5.4pt" padding-top="0.0pt" vertical-align="middle" height="0.0pt" number-columns-spanned="1">
                              <fo:block orphans="2" widows="2" linefeed-treatment="preserve" start-indent="0.0pt" text-align="start" padding-bottom="0.0pt" end-indent="0.0pt" padding-top="0.0pt">
                                 <fo:inline white-space-collapse="false"  height="12.0pt"  font-family="Calibri" font-size="12.0pt" font-weight="bold" color="#ff0000">Wir machen aus Daten Wissen</fo:inline>
                              </fo:block>
                           </fo:table-cell>
                           <fo:table-cell padding-end="5.4pt" padding-bottom="0.0pt" padding-start="5.4pt" padding-top="0.0pt" vertical-align="top" height="0.0pt" number-columns-spanned="1">
                              <fo:block orphans="2" widows="2" linefeed-treatment="preserve" start-indent="0.0pt" text-align="right" padding-bottom="0.0pt" end-indent="0.0pt" padding-top="0.0pt" height="0.0pt">
                                 <fo:inline><fo:external-graphic src="url(''http://www.frt.at/fileadmin/templates/main/css/img/header_top_bg_n-de.gif'')"/></fo:inline>
                              </fo:block>
                           </fo:table-cell>
                        </fo:table-row>
                     </fo:table-body>
                  </fo:table>
               </fo:block>
               <fo:block  orphans="2" widows="2" linefeed-treatment="preserve" start-indent="5.4pt" text-align="center" padding-bottom="10.0pt" end-indent="5.4pt" padding-top="0.0pt" height="0.0pt">
                  <fo:inline white-space-collapse="false"  height="0.0pt"  font-family="Arial Black" font-size="22.0pt"  font-weight="bold" color="#244061">Sample report layout</fo:inline>
               </fo:block>
               <xsl:variable name="_XDOFOOSTOTAL" select="(number(concat(''0'', $_XDOFOPOS2)) - 1) * number(concat(''0'', $_XDOFOTOTAL))"/>
               <xsl:for-each select="/DOCUMENT/DATA/ROWSET">
                  <xsl:variable name="_XDOFOPOS" select="concat($_XDOFOPOS, ''_'', position())"/>
                  <xsl:variable name="_XDOFOPOS2" select="number(concat(''0'', $_XDOFOOSTOTAL)) + position()"/>
                  <fo:block   orphans="2" widows="2" linefeed-treatment="preserve" start-indent="5.4pt" text-align="start" padding-bottom="10.0pt" end-indent="5.4pt" padding-top="0.0pt" height="0.0pt">
                     <fo:inline white-space-collapse="false"  height="0.0pt"  font-family="Calibri" font-size="11.0pt" >
                        <xsl:value-of select="((.//BREAK_HEADER)[1])[1]" />
                     </fo:inline>
                  </fo:block>
                  <fo:block  orphans="2" widows="2" linefeed-treatment="preserve" text-align="start" padding-bottom="0.25pt" end-indent="5.4pt" padding-top="0.25pt">
                     <fo:table start-indent="0.0pt"     >
                        <xsl:variable name="_XDOFOPOS2" select="number(1)"/>
                        <xsl:variable name="_XDOFOTOTAL" select="number(1)"/>
                        <xsl:for-each select="(.//HEADER/COL/..)[1]/COL">
                           <fo:table-column column-width="{concat(string(451.95*number(.//@width) div sum(.././/@width)), ''pt'')}"/>
                        </xsl:for-each>
                        <fo:table-header>
                           <fo:table-row keep-with-next="always" >
                              <xsl:variable name="_XDOFOOSTOTAL" select="(number(concat(''0'', $_XDOFOPOS2)) - 1) * number(concat(''0'', $_XDOFOTOTAL))"/>
                              <xsl:for-each select="(.//HEADER/COL/..)[1]/COL">
                                 <xsl:variable name="_XDOFOPOS" select="concat($_XDOFOPOS, ''_'', position())"/>
                                 <xsl:variable name="_XDOFOPOS2" select="number(concat(''0'', $_XDOFOOSTOTAL)) + position()"/>
                                 <fo:table-cell padding-start="5.15pt" vertical-align="top" border-bottom="0.5pt solid #000000" border-end-color="#000000" padding-top="0.0pt" border-end-style="solid" border-start-color="#000000" padding-end="5.15pt" number-columns-spanned="1" border-top="0.5pt solid #000000" border-start-style="solid" height="13.65pt" border-end-width="0.5pt" padding-bottom="0.0pt" border-start-width="0.5pt" background-color="#95b3d7">
                                    <fo:block  orphans="2" widows="2" linefeed-treatment="preserve" start-indent="0.0pt" text-align="center" padding-bottom="0.0pt" end-indent="0.0pt" padding-top="0.0pt" height="0.0pt">
                                       <fo:inline white-space-collapse="false"  height="11.0pt"  font-family="Calibri" font-size="11.0pt" font-weight="bold">
                                          <xsl:value-of select="." />
                                       </fo:inline>
                                    </fo:block>
                                 </fo:table-cell>
                              </xsl:for-each>
                           </fo:table-row>
                        </fo:table-header>
                        <fo:table-body>
                           <xsl:variable name="_XDOFOOSTOTAL" select="(number(concat(''0'', $_XDOFOPOS2)) - 1) * number(concat(''0'', $_XDOFOTOTAL))"/>
                           <xsl:variable name="_XDOFOTOTAL" select="count(.//ROW)"/>
                           <xsl:for-each select=".//ROW" >
                              <xsl:variable name="_XDOFOPOS" select="concat($_XDOFOPOS, ''_'', position())"/>
                              <xsl:variable name="_XDOFOPOS2" select="number(concat(''0'', $_XDOFOOSTOTAL)) + position()"/>
                              <fo:table-row >
                                 <xsl:variable name="_XDOFOOSTOTAL" select="(number(concat(''0'', $_XDOFOPOS2)) - 1) * number(concat(''0'', $_XDOFOTOTAL))"/>
                                 <xsl:for-each select=".//COL">
                                    <xsl:variable name="_XDOFOPOS" select="concat($_XDOFOPOS, ''_'', position())"/>
                                    <xsl:variable name="_XDOFOPOS2" select="number(concat(''0'', $_XDOFOOSTOTAL)) + position()"/>
                                    <fo:table-cell padding-start="5.15pt" vertical-align="top" border-bottom="0.5pt solid #000000" border-end-color="#000000" padding-top="0.0pt" border-end-style="solid" border-start-color="#000000" padding-end="5.15pt" number-columns-spanned="1" border-top="0.5pt solid #000000" border-start-style="solid" height="0.0pt" border-end-width="0.5pt" padding-bottom="0.0pt" border-start-width="0.5pt">
                                       <fo:block  orphans="2" widows="2" linefeed-treatment="preserve" start-indent="0.0pt" text-align="start" padding-bottom="0.0pt" end-indent="0.0pt" padding-top="0.0pt">
                                          <xsl:attribute name="color">
                                             <xsl:value-of select=".//@color" />
                                          </xsl:attribute>
                                          <xsl:attribute name="text-align">
                                             <xsl:value-of select=".//@align" />
                                          </xsl:attribute>
                                          <fo:inline  white-space-collapse="false"  height="11.0pt"  font-family="Calibri" font-size="11.0pt" font-weight="bold"> </fo:inline>
                                          <fo:inline  white-space-collapse="false"  height="11.0pt"  font-family="Calibri" font-size="11.0pt"><xsl:value-of select="." /> </fo:inline>
                                       </fo:block>
                                    </fo:table-cell>
                                 </xsl:for-each>
                              </fo:table-row>
                              
                           </xsl:for-each>
                           <fo:table-row >
                              <xsl:variable name="_XDOFOOSTOTAL" select="(number(concat(''0'', $_XDOFOPOS2)) - 1) * number(concat(''0'', $_XDOFOTOTAL))"/>
                              <xsl:for-each select=".//AGGREGATE/COL">
                                 <xsl:variable name="_XDOFOPOS" select="concat($_XDOFOPOS, ''_'', position())"/>
                                 <xsl:variable name="_XDOFOPOS2" select="number(concat(''0'', $_XDOFOOSTOTAL)) + position()"/>
                                 <fo:table-cell padding-start="5.15pt" vertical-align="top" border-bottom="0.5pt solid #000000" border-end-color="#000000" padding-top="0.0pt" border-end-style="solid" border-start-color="#000000" padding-end="5.15pt" number-columns-spanned="1" border-top="0.5pt solid #000000" border-start-style="solid" height="0.0pt" border-end-width="0.5pt" padding-bottom="0.0pt" border-start-width="0.5pt">
                                    <fo:block  orphans="2" widows="2" linefeed-treatment="preserve" start-indent="0.0pt" text-align="right" padding-bottom="0.0pt" end-indent="0.0pt" padding-top="0.0pt" height="0.0pt">
                                       <fo:inline white-space-collapse="false"  height="11.0pt"  font-family="Calibri" font-size="11.0pt" font-weight="bold" color="#632423">
                                          <xsl:value-of select="." />
                                       </fo:inline>
                                    </fo:block>
                                 </fo:table-cell>
                              </xsl:for-each>
                           </fo:table-row>
                        </fo:table-body>
                     </fo:table>
                  </fo:block>
               </xsl:for-each>
               <fo:block  orphans="2" widows="2" linefeed-treatment="preserve" start-indent="5.4pt" text-align="start" padding-bottom="10.0pt" end-indent="5.4pt" padding-top="0.0pt" height="0.0pt" font-size="11.0pt" font-family="Calibri">
                  <fo:inline id="{concat(''page-total-'', $_SECTION_NAME, $_XDOFOPOS)}"/>
                  <fo:inline id="{concat(''page-total'', $_XDOFOPOS)}"/>
               </fo:block>
            </fo:flow>
         </fo:page-sequence>
      </fo:root>
   </xsl:template>
</xsl:stylesheet>

';


END IR_TO_XML;
/


CREATE OR REPLACE PACKAGE BODY IR_TO_XML AS   
  --grant update,select,references  on APEX_040200.WWV_FLOW_REPORT_LAYOUTS to gpv;
  --create view APEX_REPORT_LAYOUTS as select * from APEX_040200.WWV_FLOW_REPORT_LAYOUTS


  DEFAULT_FONT_COLOR constant varchar2(10) default 'black';  
  DEFAULT_BACK_COLOR constant varchar2(10) default 'white';
  
  cursor cur_highlight(p_report_id in APEX_APPLICATION_PAGE_IR_RPT.REPORT_ID%TYPE) is
  select replace(replace(replace(replace(condition_sql,'#APXWS_EXPR#',CONDITION_EXPRESSION),'#APXWS_EXPR2#',CONDITION_EXPRESSION2),'#APXWS_HL_ID#','1'),'#APXWS_CC_EXPR#','"'||CONDITION_COLUMN_NAME||'"')  condition_sql,
       CONDITION_COLUMN_NAME,
       CONDITION_ENABLED,
       HIGHLIGHT_ROW_COLOR,
       HIGHLIGHT_ROW_FONT_COLOR,
       HIGHLIGHT_CELL_COLOR,
       HIGHLIGHT_CELL_FONT_COLOR,
       rownum COND_NUMBER,
       'HIGHLIGHT_'||rownum COND_NAME
  from APEX_APPLICATION_PAGE_IR_COND
  where condition_type = 'Highlight'
    and report_id = p_report_id
    and condition_enabled = 'Yes'
    order by --rows highlights first
           nvl2(HIGHLIGHT_ROW_COLOR,1,0) desc, 
           nvl2(HIGHLIGHT_ROW_FONT_COLOR,1,0) desc,
           HIGHLIGHT_SEQUENCE;
  
  type t_col_names is table of APEX_APPLICATION_PAGE_IR_COL.report_label%TYPE index by APEX_APPLICATION_PAGE_IR_COL.column_alias%TYPE;
  type t_col_format_mask is table of APEX_APPLICATION_PAGE_IR_COMP.computation_format_mask%TYPE index by APEX_APPLICATION_PAGE_IR_COL.column_alias%TYPE;
  type t_header_alignment is table of APEX_APPLICATION_PAGE_IR_COL.heading_alignment%TYPE index by APEX_APPLICATION_PAGE_IR_COL.column_alias%TYPE;
  type t_column_alignment is table of APEX_APPLICATION_PAGE_IR_COL.column_alignment%TYPE index by APEX_APPLICATION_PAGE_IR_COL.column_alias%TYPE;
  
  type t_highlight is table of cur_highlight%ROWTYPE index by binary_integer;
  
  type ir_report is record
   (
    report                    apex_ir.t_report,
    ir_data                   APEX_APPLICATION_PAGE_IR_RPT%ROWTYPE,
    report_columns            APEX_APPLICATION_GLOBAL.VC_ARR2,
    break_on                  APEX_APPLICATION_GLOBAL.VC_ARR2,
    break_really_on           APEX_APPLICATION_GLOBAL.VC_ARR2, -- "break on" except hidden columns
    sum_columns_on_break      APEX_APPLICATION_GLOBAL.VC_ARR2,
    avg_columns_on_break      APEX_APPLICATION_GLOBAL.VC_ARR2,
    max_columns_on_break      APEX_APPLICATION_GLOBAL.VC_ARR2,
    min_columns_on_break      APEX_APPLICATION_GLOBAL.VC_ARR2,
    median_columns_on_break   APEX_APPLICATION_GLOBAL.VC_ARR2,
    count_columns_on_break    APEX_APPLICATION_GLOBAL.VC_ARR2,
    count_distnt_col_on_break APEX_APPLICATION_GLOBAL.VC_ARR2,
    skipped_columns           INTEGER default 0, -- when scpecial coluns like apxws_row_pk is used
    start_with                INTEGER default 0, -- position of first displayed column in query
    end_with                  INTEGER default 0, -- position of last displayed column in query
    agg_cols_cnt              INTEGER default 0, 
    column_names              t_col_names,       -- column names in report header
    col_format_mask           t_col_format_mask, -- format like $3849,56
    row_highlight             t_highlight,
    col_highlight             t_highlight,
    header_alignment          t_header_alignment,
    column_alignment          t_column_alignment
   );  
  ------------------------------------------------------------------------------
  function bcoll(p_cell_order   in integer,
                 p_font_color in varchar2 default null,
                 p_back_color in varchar2 default null,
                 p_align      in varchar2 default null ) 
  return varchar2
  is
  begin
    if p_font_color is not null then
      return '<COL color="'||p_font_color||'" background-color="'||p_back_color||'" align="'||lower(p_align)||'" width="10">';
    else
      return '<COL width="10">';
    end if;
  end bcoll;
  ------------------------------------------------------------------------------
  function ecoll(i integer) 
  return varchar2
  is
  begin
   return '</COL>';
  end ecoll;
  ------------------------------------------------------------------------------
  -- :::: -> :
  function rr(p_str in varchar2)
  return varchar2
  is 
  begin
    return ltrim(rtrim(regexp_replace(p_str,'[:]+',':'),':'),':');
  end;
  ------------------------------------------------------------------------------   
  function get_xmlval(p_str in varchar2)
  return varchar2
  is   
  begin
    return replace(replace(replace(replace(replace(p_str,'<','&lt;'),'>','&gt;'),'&','&amp;'),'"','&quot;'),'''','&apos;');
  end get_xmlval;
  
  ------------------------------------------------------------------------------  
  function intersect_arrays(p_one IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                            p_two IN APEX_APPLICATION_GLOBAL.VC_ARR2)
  return APEX_APPLICATION_GLOBAL.VC_ARR2
  is    
    v_ret APEX_APPLICATION_GLOBAL.VC_ARR2;
  begin    
    for i in 1..p_one.count loop
       for b in 1..p_two.count loop
         if p_one(i) = p_two(b) then
            v_ret(v_ret.count + 1) := p_one(i);
           exit;
         end if;
       end loop;        
    end loop;
    
    return v_ret;
  exception
    when others then
      raise_application_error(-20001,'intersect_arrays '||SQLERRM);
  end intersect_arrays;  
  ------------------------------------------------------------------------------
  function is_in_array(p_one IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                       p_val IN varchar2)
  return boolean
  is    
    v_ret APEX_APPLICATION_GLOBAL.VC_ARR2;
  begin    
    for i in 1..p_one.count loop
         if p_one(i) = p_val then
            return true;
         end if;
    end loop;    
    
    return false;    
  exception
    when others then
      raise_application_error(-20001,'is_in_array '||SQLERRM);
  end is_in_array;    
  ------------------------------------------------------------------------------
  function intersect_count(p_one IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                           p_two IN APEX_APPLICATION_GLOBAL.VC_ARR2)
  return integer
  is
   v_rez APEX_APPLICATION_GLOBAL.VC_ARR2;
  begin
    v_rez := intersect_arrays(p_one,p_two);
    return v_rez.count;
  end intersect_count;

  ------------------------------------------------------------------------------
  function get_t_report(p_app_id       in number,
                        p_page_id      in number,
                        p_ir_static_id in varchar2 default null,
                        p_report_id    In number default null 
                      )
  return ir_report
  is
    l_region_id     number;
    l_report        ir_report;
    l_report_id     number;
    v_query_targets APEX_APPLICATION_GLOBAL.VC_ARR2;
  begin
    select region_id 
    into l_region_id 
    from APEX_APPLICATION_PAGE_REGIONS 
    where application_id = p_app_id 
      and page_id = p_page_id 
      and nvl(static_id,'~') = nvl(p_ir_static_id,'~')
      and source_type = 'Interactive Report';    
      
    if p_report_id is not null then
      select * 
      into l_report.ir_data
      from APEX_APPLICATION_PAGE_IR_RPT
      where report_id = p_report_id;
    else          
      --get base report id
      l_report_id := APEX_IR.GET_LAST_VIEWED_REPORT_ID (p_page_id   => p_page_id,
                                                        p_region_id => l_region_id);
      select r.* 
      into l_report.ir_data       
      from APEX_APPLICATION_PAGE_IR_RPT r
      where base_report_id = l_report_id
        and session_id = v('APP_SESSION');
     
      l_report_id := l_report.ir_data.report_id;                                                                 
      
      l_report.report := apex_ir.get_report (p_page_id        => p_page_id,
                                             p_region_id      => l_region_id,
                                             p_report_id      => l_report_id);
     
    end if;                                                       
     
    l_report.report_columns := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.report_columns));
    l_report.break_on := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.break_enabled_on));    
    l_report.sum_columns_on_break := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.sum_columns_on_break));  
    l_report.avg_columns_on_break := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.avg_columns_on_break));  
    l_report.max_columns_on_break := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.max_columns_on_break));  
    l_report.min_columns_on_break := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.min_columns_on_break));  
    l_report.median_columns_on_break := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.median_columns_on_break)); 
    l_report.count_columns_on_break := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.count_columns_on_break));  
    l_report.count_distnt_col_on_break := APEX_UTIL.STRING_TO_TABLE(rr(l_report.ir_data.count_distnt_col_on_break)); 
    l_report.break_really_on := intersect_arrays(l_report.report_columns,l_report.break_on);  
    
    for i in (select column_alias,
                     report_label,
                     heading_alignment,
                     column_alignment,
                     null as  computation_format_mask
                from APEX_APPLICATION_PAGE_IR_COL
               where application_id = p_app_id
                 and page_id = p_page_id
              union
              select computation_column_alias,
                     computation_report_label,
                     'center' as heading_alignment,
                     'right' as column_alignment,
                     computation_format_mask
              from APEX_APPLICATION_PAGE_IR_COMP
              where application_id = p_app_id
                and page_id = p_page_id
                and report_id = l_report_id
              )
    loop                 
      l_report.column_names(i.column_alias) := i.report_label; 
      l_report.col_format_mask(i.column_alias) := i.computation_format_mask;
      l_report.header_alignment(i.column_alias) := i.heading_alignment; 
      l_report.column_alignment(i.column_alias) := i.column_alignment; 
    end loop;
    
     v_query_targets(v_query_targets.count + 1) := 'rez.*';
     
    for c in cur_highlight(p_report_id => l_report_id) loop
      if is_in_array(l_report.report_columns,upper(c.CONDITION_COLUMN_NAME)) then
        if c.HIGHLIGHT_ROW_COLOR is not null or c.HIGHLIGHT_ROW_FONT_COLOR is not null then
          --is row highlight
          l_report.row_highlight(l_report.row_highlight.count + 1) := c;        
        else
          l_report.col_highlight(l_report.col_highlight.count + 1) := c;           
        end if;  
        v_query_targets(v_query_targets.count + 1) := c.condition_sql;
      end if;  
    end loop;    
        
    l_report.report.sql_query := 'SELECT '||APEX_UTIL.TABLE_TO_STRING(v_query_targets,',')||' from ( '
                                          ||l_report.report.sql_query||' ) rez';
    
    return l_report;
  exception
    when no_data_found then
     if p_ir_static_id is not  null then
       raise_application_error(-20001,'No Interactive Report found on Page='||p_page_id||' Application='||p_app_id||' with Report Static Id='||p_ir_static_id);
     else
        raise_application_error(-20001,'No Interactive Report found on Page='||p_page_id||' Application='||p_app_id);
     end if;
    when too_many_rows then
     if p_ir_static_id is not  null then
       raise_application_error(-20001,'No Interactive Report found on Page='||p_page_id||' Application='||p_app_id||' with Report Static Id='||p_ir_static_id||'.Please give unique static id to the report.');
     else
        raise_application_error(-20001,'No Interactive Report found on Page='||p_page_id||' Application='||p_app_id||'.Please give and use unique static id to the report.');
     end if;
    when others then 
      raise_application_error(-20001,'get_t_report: Page='||p_page_id||' Application='||p_app_id||' '||SQLERRM);
  end get_t_report;  
 
  ------------------------------------------------------------------------------
  -- debug only
  function get_report_query(p_app_id       in number,
                            p_page_id      in number,
                            p_ir_static_id in varchar2 default null
                           )
  return varchar2
  is
   l_report ir_report;
  begin
    l_report := get_t_report(p_app_id,p_page_id);
    return l_report.report.sql_query;
  end get_report_query;
  ------------------------------------------------------------------------------
 
  function is_control_break(p_curr_row  IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                            p_prev_row  IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                            l_report    IN ir_report
                           )
  return boolean
  is
    v_start_with      integer;
    v_end_with        integer;    
    v_tmp             integer;
  begin
    if nvl(l_report.break_really_on.count,0) = 0  then
      return false; --no control break
    end if;

    v_start_with := 1 + l_report.skipped_columns;    
    v_end_with   := l_report.skipped_columns + nvl(l_report.break_really_on.count,0);
    for i in v_start_with..v_end_with loop
      if p_curr_row(i) != p_prev_row(i) then
        return true;
      end if;
    end loop;
    return false;
  exception
    when others then
      raise_application_error(-20001,'is_control_break '||SQLERRM||' v_start_with='||v_start_with||' v_end_with='||v_end_with||' l_report.ir_data.report_id='|| l_report.ir_data.report_id||' v_tmp='||v_tmp);
  end is_control_break;

  ------------------------------------------------------------------------------  
  function get_formatted_str(p_val in varchar2, p_format in varchar2)
  return varchar2
  is
  begin
    if p_format is null then
      return p_val;
    else  
      return to_char(p_val,p_format);
    end if;  
  exception
    when others then
      return p_val;
  end get_formatted_str;
  
  ------------------------------------------------------------------------------  

  function print_row(p_current_row     IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                     l_report          IN ir_report)
  return clob is
    v_clob            clob;
    v_column_alias    APEX_APPLICATION_PAGE_IR_COL.column_alias%TYPE;
    v_format_mask     APEX_APPLICATION_PAGE_IR_COMP.computation_format_mask%TYPE;
    v_row_color       varchar2(10) default DEFAULT_FONT_COLOR; 
    v_row_back_color  varchar2(10) default DEFAULT_BACK_COLOR;
    v_cell_color      varchar2(10);
    v_cell_back_color varchar2(10);        
  begin
    --check that row need to be highlighted
    for h in 1..l_report.row_highlight.count loop
      if p_current_row(l_report.end_with + l_report.agg_cols_cnt + l_report.row_highlight(h).COND_NUMBER) is not null then
         v_row_color       := l_report.row_highlight(h).HIGHLIGHT_ROW_FONT_COLOR;
         v_row_back_color  := l_report.row_highlight(h).HIGHLIGHT_ROW_COLOR;
      end if;        
    end loop;

    for i in l_report.start_with..l_report.end_with loop
      v_cell_color       := null;
      v_cell_back_color  := null;
    
      v_column_alias := l_report.report_columns(i);
      v_format_mask := l_report.col_format_mask(v_column_alias);

      --check that cell need to be highlighted
      for h in 1..l_report.col_highlight.count loop
        if p_current_row(l_report.end_with + l_report.agg_cols_cnt + l_report.col_highlight(h).COND_NUMBER) is not null and v_column_alias = l_report.col_highlight(h).CONDITION_COLUMN_NAME then
          v_cell_color       := l_report.col_highlight(h).HIGHLIGHT_CELL_FONT_COLOR;
          v_cell_back_color  := l_report.col_highlight(h).HIGHLIGHT_CELL_COLOR;
        end if;        
      end loop;
                 
      v_clob := v_clob ||bcoll(p_cell_order => i,
                               p_font_color => nvl(v_cell_color,v_row_color),
                               p_back_color => nvl(v_cell_back_color,v_row_back_color),
                               p_align      => l_report.column_alignment(v_column_alias)
                              )
                       ||get_xmlval(get_formatted_str(nvl(p_current_row(i),' '),v_format_mask))
                       ||ecoll(i);
    end loop;
    return  '<ROW>'||v_clob || '</ROW>'||chr(10);
  exception
    when others then
      raise_application_error(-20001,'print_row '||SQLERRM);
  end print_row;
  
  ------------------------------------------------------------------------------ 
 
  function print_header(l_report IN ir_report)
  return clob is
    v_clob            clob;
    v_column_alias    APEX_APPLICATION_PAGE_IR_COL.column_alias%TYPE;
  begin
    v_clob := v_clob || '<HEADER>';
    for i in l_report.start_with..l_report.end_with loop
      v_column_alias := l_report.report_columns(i);
      v_clob := v_clob ||bcoll(i)||l_report.column_names(v_column_alias)||ecoll(i);
    end loop;
    return  v_clob || '</HEADER>'||chr(10);
  exception
    when others then
      raise_application_error(-20001,'print_header '||SQLERRM||' v_column_alias='||v_column_alias);
  end print_header;

  ------------------------------------------------------------------------------  
  
  function print_control_break_header(p_current_row     IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                                      l_report          IN ir_report) 
  return clob
  is
    v_clob            clob;
    v_start_with      integer;
    v_end_with        integer;      
  begin
    if nvl(l_report.break_really_on.count,0) = 0  then
      return ''; --no control break
    end if;
    
    v_start_with := 1 + l_report.skipped_columns;    
    v_end_with   := l_report.skipped_columns + nvl(l_report.break_really_on.count,0);

    for i in v_start_with..v_end_with loop
      --TODO: Add column header
      v_clob := v_clob || l_report.column_names(l_report.report_columns(i))||': '||p_current_row(i)||',';
    end loop;
    return  '<BREAK_HEADER>'||get_xmlval(rtrim(v_clob,',')) || '</BREAK_HEADER>'||chr(10);
  exception
    when others then
      raise_application_error(-20001,'print_control_break_header '||SQLERRM);
  end print_control_break_header;

  ------------------------------------------------------------------------------
  function find_rel_position (p_curr_col_name    IN varchar2,
                              p_agg_rows         IN APEX_APPLICATION_GLOBAL.VC_ARR2)
  return integer
  is
    v_relative_position integer;
  begin
    for i in 1..p_agg_rows.count loop
      if p_curr_col_name = p_agg_rows(i) then        
         return i;
      end if;
    end loop;
    return null;
  exception
    when others then
      raise_application_error(-20001,'find_rel_position '||SQLERRM);
  end find_rel_position;
  
  ------------------------------------------------------------------------------
  function get_agg_text(p_curr_col_name   IN varchar2,
                        p_agg_rows        IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                        p_current_row     IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                        l_report          IN ir_report,
                        p_agg_text        IN varchar2,
                        p_position        IN integer)
  return clob
  is
    v_tmp_pos       integer;
    v_format_mask   APEX_APPLICATION_PAGE_IR_COMP.computation_format_mask%TYPE;
  begin
      v_tmp_pos := find_rel_position (p_curr_col_name,p_agg_rows); 
      if v_tmp_pos is not null then
        v_format_mask := l_report.col_format_mask(l_report.report_columns(p_position));
       if v_format_mask is not null then
          return  get_xmlval(p_agg_text||get_formatted_str(p_current_row(p_position + v_tmp_pos),v_format_mask)||chr(10));   
        else
          return  get_xmlval(p_agg_text||p_current_row(p_position + v_tmp_pos)||chr(10));   
        end if;
      end if;  
      return  '';
  exception
    when others then
      raise_application_error(-20001,'get_agg_text '||SQLERRM||' p_position='||p_position||' p_agg_text='||p_agg_text||' p_agg_rows.count='||p_agg_rows.count);
  end get_agg_text;
  
  ------------------------------------------------------------------------------
  function print_aggregate(p_current_row     IN APEX_APPLICATION_GLOBAL.VC_ARR2,
                           l_report          IN ir_report) 
  return clob
  is
    v_clob            clob;
    v_start_with      integer;
    v_end_with        integer;
    v_position        integer;    
  begin
    if intersect_count(l_report.sum_columns_on_break,l_report.report_columns) +
       intersect_count(l_report.avg_columns_on_break,l_report.report_columns) +  
       intersect_count(l_report.max_columns_on_break,l_report.report_columns) + 
       intersect_count(l_report.min_columns_on_break,l_report.report_columns) + 
       intersect_count(l_report.median_columns_on_break,l_report.report_columns) +
       intersect_count(l_report.count_columns_on_break,l_report.report_columns) +  
       intersect_count(l_report.count_distnt_col_on_break,l_report.report_columns)  = 0
    then
      return ''; --no aggregate
    end if;
    v_clob := v_clob || '<AGGREGATE>';
    
    v_start_with := l_report.skipped_columns + 1 + nvl(l_report.break_really_on.count,0);    
    v_end_with   := l_report.skipped_columns + l_report.report_columns.count;    
    
    for i in v_start_with..v_end_with loop
      v_position := v_end_with; --aggregate are placed after displayed columns
      v_clob := v_clob || bcoll(i);
      --one column cah have only one aggregate
      v_clob := v_clob || get_agg_text(p_curr_col_name => l_report.report_columns(i),
                                       p_agg_rows      => l_report.sum_columns_on_break,
                                       p_current_row   => p_current_row,
                                       l_report        => l_report,
                                       p_agg_text      => ' ',
                                       p_position      => v_position);
      v_position := v_position + l_report.sum_columns_on_break.count;
      v_clob := v_clob || get_agg_text(p_curr_col_name => l_report.report_columns(i),
                                       p_agg_rows      => l_report.avg_columns_on_break,
                                       p_current_row   => p_current_row,
                                       l_report        => l_report,
                                       p_agg_text      => 'Avg : ',
                                       p_position      => v_position);
      v_position := v_position + l_report.avg_columns_on_break.count;                                       
      v_clob := v_clob || get_agg_text(p_curr_col_name => l_report.report_columns(i),
                                       p_agg_rows      => l_report.max_columns_on_break,
                                       p_current_row   => p_current_row,
                                       l_report        => l_report,
                                       p_agg_text      => 'Max: ',
                                       p_position      => v_position);
      v_position := v_position + l_report.max_columns_on_break.count;                                 
      v_clob := v_clob || get_agg_text(p_curr_col_name => l_report.report_columns(i),
                                       p_agg_rows      => l_report.min_columns_on_break,
                                       p_current_row   => p_current_row,
                                       l_report        => l_report,
                                       p_agg_text      => 'Min: ',
                                       p_position      => v_position);
      v_position := v_position + l_report.min_columns_on_break.count;                                 
      v_clob := v_clob || get_agg_text(p_curr_col_name => l_report.report_columns(i),
                                       p_agg_rows      => l_report.median_columns_on_break,
                                       p_current_row   => p_current_row,
                                       l_report        => l_report,
                                       p_agg_text      => 'Median: ',
                                       p_position      => v_position);
      v_position := v_position + l_report.median_columns_on_break.count;                                 
      v_clob := v_clob || get_agg_text(p_curr_col_name => l_report.report_columns(i),
                                       p_agg_rows      => l_report.count_columns_on_break,
                                       p_current_row   => p_current_row,
                                       l_report        => l_report,
                                       p_agg_text      => 'Count: ',
                                       p_position      => v_position);
      v_position := v_position + l_report.count_columns_on_break.count;                                 
      v_clob := v_clob || get_agg_text(p_curr_col_name => l_report.report_columns(i),
                                       p_agg_rows      => l_report.count_distnt_col_on_break,
                                       p_current_row   => p_current_row,
                                       l_report        => l_report,
                                       p_agg_text      => 'Count distinct: ',
                                       p_position      => v_position);
      v_clob := v_clob || ecoll(i);
    end loop;
    return  v_clob || '</AGGREGATE>'||chr(10);
  exception
    when others then
      raise_application_error(-20001,'print_aggregate '||SQLERRM);
  end print_aggregate;    
  
  ------------------------------------------------------------------------------
    
  function get_xml_from_ir(l_report IN OUT NOCOPY ir_report)
  return clob
  is
   v_cur         INTEGER; 
   v_result      INTEGER;
   v_colls_count INTEGER;
   v_row         APEX_APPLICATION_GLOBAL.VC_ARR2;
   v_prev_row    APEX_APPLICATION_GLOBAL.VC_ARR2;
   v_columns     APEX_APPLICATION_GLOBAL.VC_ARR2;
   v_current_row number default 0;
   v_xml         CLOB;  
   v_desc_tab    DBMS_SQL.DESC_TAB2;
   v_inside      boolean default false;
   d             number;
  begin
    v_cur := dbms_sql.open_cursor; 

    DBMS_SQL.PARSE(v_cur,l_report.report.sql_query,DBMS_SQL.NATIVE);     
    --v_xml := v_xml||'<QUERY>'||l_report.report.sql_query||'</QUERY>'||chr(10);        
    dbms_sql.describe_columns2(v_cur,v_colls_count,v_desc_tab);    
    --skip internal primary key if need
    if lower(v_desc_tab(1).col_name) = 'apxws_row_pk' then
      l_report.skipped_columns := 1;
    end if;
    l_report.start_with := l_report.skipped_columns + 1 + nvl(l_report.break_really_on.count,0);    
    l_report.end_with   := l_report.skipped_columns + l_report.report_columns.count;    
    l_report.agg_cols_cnt := l_report.sum_columns_on_break.count + 
                             l_report.avg_columns_on_break.count +
                             l_report.max_columns_on_break.count + 
                             l_report.min_columns_on_break.count +
                             l_report.median_columns_on_break.count +
                             l_report.count_columns_on_break.count +
                             l_report.count_distnt_col_on_break.count;
    d:= 2; --bind variables
    for i in 1..l_report.report.binds.count loop
      --remove MAX_ROWS
      if l_report.report.binds(i).name = 'APXWS_MAX_ROW_CNT' then      
        DBMS_SQL.BIND_VARIABLE (v_cur,l_report.report.binds(i).name,100000000);      
        null;
      else
        DBMS_SQL.BIND_VARIABLE (v_cur,l_report.report.binds(i).name,l_report.report.binds(i).value);      
      end if;
    end loop;
    d:= 3; 
    for i in 1..v_colls_count loop
     v_row(i) := '';
     DBMS_SQL.DEFINE_COLUMN(v_cur, i, v_row(i),32767);
    end loop;
    d:= 4;
    
    v_result := DBMS_SQL.EXECUTE(v_cur);     
    
    LOOP 
         IF DBMS_SQL.FETCH_ROWS(v_cur)>0 THEN          
           -- get column values of the row 
            v_current_row := v_current_row + 1;
            for i in 1..v_colls_count loop
               DBMS_SQL.COLUMN_VALUE(v_cur, i,v_row(i));                
            end loop;     
            --check control break
            --v_xml := v_xml||'<ROWNUM>'||v_current_row||'</ROWNUM>'||chr(10);
            if v_current_row > 1 then
             if is_control_break(v_row,v_prev_row,l_report) then                                             
               v_xml := v_xml||'</ROWSET>'||chr(10);
               v_inside := false;
             end if;
            end if;
            if not v_inside then
              v_xml := v_xml||'<ROWSET>'||chr(10);
              v_xml := v_xml||print_header(l_report);
              v_xml := v_xml||print_control_break_header(v_row,l_report);              
              --print aggregates
              v_xml := v_xml||print_aggregate(v_row,l_report);
              v_inside := true;
            end if;            --            
            
            for i in 1..v_colls_count loop
              v_prev_row(i) := v_row(i);                           
            end loop;                 
            v_xml := v_xml||print_row(v_row,l_report);            
         ELSE 
           EXIT; 
         END IF; 
    END LOOP;        
    if v_inside then
       v_xml := v_xml||'</ROWSET>';
       v_inside := false;
    end if;

   dbms_sql.close_cursor(v_cur); 
   
   return '<?xml version="1.0" encoding="UTF-8"?>'||chr(10)||
          '<DOCUMENT>'||chr(10)||           
          '<DATA>'||chr(10)||
           v_xml||
          '</DATA>'||chr(10)||
          '</DOCUMENT>';
  exception
    when others then 
      raise_application_error(-20001,'get_sql_from_ir: '||SQLERRM||' '||d);
  end get_xml_from_ir;
  
  ------------------------------------------------------------------------------  
  function get_report_xml(p_app_id       in number,
                          p_page_id      in number,
                          p_ir_static_id in varchar2 default null)
  return clob
  is
    l_report ir_report;
  begin
    l_report := get_t_report(p_app_id       => p_app_id,
                             p_page_id      => p_page_id,
                             p_ir_static_id => p_ir_static_id
                            );    
    return get_xml_from_ir(l_report);    
  end;
  ------------------------------------------------------------------------------    
  --http://13ter.info/blog/?p=364
  FUNCTION blob_to_clob (p_in blob) RETURN clob IS
    v_clob    clob;
    v_varchar VARCHAR2(32767);
    v_start   PLS_INTEGER := 1;
    v_buffer  PLS_INTEGER := 32767;   
  BEGIN
    dbms_lob.createtemporary(v_clob, TRUE);
    FOR i IN 1..CEIL(dbms_lob.getlength(p_in) / v_buffer)
    LOOP
      v_varchar := utl_raw.cast_to_varchar2(dbms_lob.SUBSTR(p_in, v_buffer, v_start));
      dbms_lob.writeappend(v_clob, LENGTH(v_varchar), v_varchar);
      v_start := v_start + v_buffer;
    END LOOP;
    RETURN v_clob;
  END;
  ------------------------------------------------------------------------------   
  function get_query_template(p_layout_id in APEX_REPORT_LAYOUTS.id%TYPE)
  return clob
  is
     v_template clob;
  begin
     select page_template
     into v_template
     from APEX_REPORT_LAYOUTS 
     where ID = p_layout_id;
  
     return  v_template;
  exception
    when others then 
      raise_application_error(-20001,'Error in IR_TO_XML.get_query_template '||SQLERRM);
  end get_query_template;
  ------------------------------------------------------------------------------   
  procedure get_report_document(p_app_id       in number,
                                p_layout_id in APEX_REPORT_LAYOUTS.id%TYPE,
                                p_page_id      in number,                               
                                p_ir_static_id in varchar2 default null
                              )
  is
    v_data      clob;
    l_report    ir_report;
  begin
    l_report := get_t_report(p_app_id,p_page_id,p_ir_static_id);    
    v_data := get_xml_from_ir(l_report);

    APEX_UTIL.DOWNLOAD_PRINT_DOCUMENT (
        p_file_name           => 'download',
        p_content_disposition => 'inline',
        p_report_data         => v_data,                
        p_report_layout       => get_query_template(p_layout_id),--t_template,
        p_document_format     => 'pdf'
    );
  end get_report_document; 
  
END IR_TO_XML;
/
